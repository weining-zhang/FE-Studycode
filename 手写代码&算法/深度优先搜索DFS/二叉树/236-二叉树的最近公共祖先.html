<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    /* 
      https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/
      思路：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-ale/

      🧠 思考递归逻辑
        递归中有三种情况：
        1. 终止条件：
          - root === null → 空节点，没有找到；
          - root === p 或 root === q → 找到目标节点，直接返回它。

        2. 递归左右子树：
          let left = lowestCommonAncestor(root.left, p, q);
          let right = lowestCommonAncestor(root.right, p, q);
          
        3. 根据左右子树结果判断：
          - 如果左右都非空 → 说明 p、q 分别在两侧 ⇒ 当前节点 root 是最近公共祖先；
          - 如果只有一侧非空 → 说明两个节点都在同一侧 ⇒ 返回那一侧；
          - 如果两边都空 → 返回 null。

      
      📊 执行过程举例
        以刚才的树为例，找 p=5，q=1：
               3
              / \
             5   1
            / \ / \
           6  2 0  8

        | 当前节点 | 左递归结果            | 右递归结果  | 返回   |
        | ----    | ---------------     | ------ | ---- |
        | 节点 5 | 找到 p=5 → 返回 5      | —      | 5    |
        | 节点 1 | 找到 q=1 → 返回 1      | —      | 1    |
        | 节点 3 | left=5, right=1       | ✅ 两边都有 | 返回 3 |


        找 p=1，q=5：
               3
              /
             5
            /
           1

        | 当前递归层 | root | left 结果       | right 结果 | 返回值      | 说明            |
        | -----     | ---- | -------------- | -------- | -------    | ------------- |
        | 第1层     | 3    | 调用 LCA(5,1,5)  | null     | 返回 left  | 因为只有左边找到结果 |
        | 第2层     | 5    | 调用 LCA(1,1,5)  | null     | 返回自身(5) | root === q 成立 |
        | 第3层     | 1    | return root(1)  | —        | 1          | root === p 成立 |

     */
    function lowestCommonAncestor(root, p, q) {
      // 情况1：到达空节点，或找到目标节点之一
      if (root === null || root === p || root === q) return root;

      // 情况2：递归搜索左右子树
      let left = lowestCommonAncestor(root.left, p, q);
      let right = lowestCommonAncestor(root.right, p, q);

      // 情况3：如果左右子树都找到了非空节点，说明p、q分属两侧
      if (left && right) return root;

      // 情况4：否则p和q在同一侧（或者没找到）
      return left ? left : right;
    }
  </script>
</body>
</html>