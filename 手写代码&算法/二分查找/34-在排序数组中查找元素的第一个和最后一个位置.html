<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    /**
     * https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/504484/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/?envType=study-plan-v2&envId=top-100-liked
     * 高赞评论2023.04.14
     * 
     * 🧠 思路分析
        核心：
        ➡️ 我们要找到 target 的左右边界，不能只找到任意一个匹配位置。

        所以用两次二分查找：
          - 第一次 找 target 的最左边位置（第一个出现位置）；
          - 第二次 找 target 的最右边位置（最后一个出现位置）。


      💡 为什么要用两次二分查找？

        一次普通的二分只能找到“某个目标值的位置”，
        而我们需要找到：
          - 第一个出现的 target（要往左探）；
          - 最后一个出现的 target（要往右探）。

        ➡️ 所以逻辑必须跑两遍。
        每一遍在找到目标时，不是立刻返回，而是：
          - “先记录结果，再继续往左/右找，直到找不到为止。”
     */ 
    var searchRange = function(nums, target) {
      let left = 0;
      let right = nums.length - 1;
      let first = -1;
      let last = -1;

      // 第一次二分：找最左边（第一个）target
      while (left <= right) {
        let mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
          first = mid;         // 暂存当前位置
          right = mid - 1;     // 往左边继续找，看还有没有更左的 target
        } else if (nums[mid] > target) {
          right = mid - 1;     // target 在左边
        } else {
          left = mid + 1;      // target 在右边
        }
      }

      // 第二次二分：找最右边（最后一个）target
      left = 0;
      right = nums.length - 1;

      while (left <= right) {
        let mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
          last = mid;          // 暂存当前位置
          left = mid + 1;      // 往右边继续找，看还有没有更右的 target
        } else if (nums[mid] > target) {
          right = mid - 1;
        } else {
          left = mid + 1;
        }
      }

      return [first, last];
    };
  </script>
</body>
</html>