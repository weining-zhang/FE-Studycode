<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    /* 
      思路：https://leetcode-cn.com/problems/house-robber/solution/hua-jie-suan-fa-198-da-jia-jie-she-by-guanpengchn/

      🔹 DP 思路拆解
        1. 子问题
        到第 i 个房子时，最多能偷多少钱？

        2. 状态定义
        设 dp[i] 表示 前 i 个房子能偷到的最大金额。

        3. 转移方程
        对于第 i 个房子（下标从 0 开始）：
        - 偷：那就不能偷 i-1，金额是 dp[i-2] + nums[i]；
        - 不偷：那就是 dp[i-1]；
          取两者最大：dp[i]=max(dp[i−1],dp[i−2]+nums[i])

        4. 初始条件
          - dp[0] = nums[0]（只有一个房子，只能偷它）
          - dp[1] = max(nums[0], nums[1])（前两个房子，选一个金额大的）

        5. 最终答案
        dp[n-1]（最后一个房子对应的最大金额）
    */
    var rob = function(nums) {
      let dp = [];
      dp[0] = nums[0];
      dp[1] = Math.max(nums[0], nums[1]);
      let n = nums.length;

      for (let i = 2; i < n; i++) {
        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
      }

      return dp[n-1];

      // let n = nums.length;
      
      // let dp = [];
      // dp[0] = 0;
      // dp[1] = nums[0];

      // for (let i = 2; i < n + 1; i++) {
      //   dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);
      // }

      // return dp[n];
    };
  </script>
</body>
</html>